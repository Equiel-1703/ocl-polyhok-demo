defmodule OCLPolyHok.OpenCLBackend do
  @doc """
  Generates a new Elixir module AST with a custom `__using__/1` macro and transformed function definitions.

  ## Parameters

    - `header`: The module header AST, typically an `{:__aliases__, _, [module_name]}` tuple representing the module name.
    - `body`: The body of the module, which can be a single definition or a block of definitions.

  ## Returns

    - An Elixir quoted expression (`quote`) that defines a new module with:
      - A `__using__/1` macro that invokes `JIT.process_module/2` with the module name and original body.
      - The transformed function definitions generated by `gen_new_definitions/1`.
  """
  def gen_new_module(header, body) do
    new_body =
      case body do
        {:__block__, [], definitions} -> gen_new_definitions(definitions)
        _ -> gen_new_definitions([body])
      end

    {:__aliases__, _, [module_name]} = header

    # The 'JIT.process_module' line is the same called in OCLPolyHok.defmodule macro.
    # It is here to ensure that the body will always be processed during runtime.
    using =
      quote do
        defmacro __using__(_opts) do
          JIT.process_module(unquote(module_name), unquote(Macro.escape(body)))
        end
      end

    new_module =
      quote do
        defmodule unquote(header) do
          unquote([using | new_body])
        end
      end

    new_module
  end

  # ------ Helper functions to generate new definitions for the module ------

  defp gen_new_definitions([]), do: []

  defp gen_new_definitions([{:deft, _, _para} | t]) do
    gen_new_definitions(t)
  end

  defp gen_new_definitions([{:include, _, _para} | t]) do
    gen_new_definitions(t)
  end

  defp gen_new_definitions([{:defd, _, [header, _code]} | t]) do
    {fname, comp_info, para} = header

    para =
      para
      |> Enum.map(fn {p, b, c} -> {String.to_atom("_" <> to_string(p)), b, c} end)

    new_code =
      quote do:
              def(unquote({fname, comp_info, para}),
                do: raise("A device function can only be called by kernels!")
              )

    [new_code | gen_new_definitions(t)]
  end

  defp gen_new_definitions([{:defk, _, [header, _code]} | t]) do
    {fname, comp_info, para} = header

    para =
      para
      |> Enum.map(fn {p, b, c} -> {String.to_atom("_" <> to_string(p)), b, c} end)

    new_code =
      quote do:
              def(unquote({fname, comp_info, para}),
                do: raise("A kernel can only be executed with spawn!")
              )

    [new_code | gen_new_definitions(t)]
  end

  defp gen_new_definitions([h | t]) do
    # IO.inspect h
    [h | gen_new_definitions(t)]
  end

  @doc """
  Creates a unique name for anonymous functions (lambdas) by generating a random string of 10 characters.

  ## Returns

    - A string of 10 random characters chosen from the set "0123456789abcdefghijklmno".
  """
  def gen_lambda_name() do
    for _ <- 1..10, into: "", do: <<Enum.random(~c"0123456789abcdefghijklmno")>>
  end

  @doc """
  Generates the parameter declaration string for OpenCL kernel/function based on the parameter name and its type.

  ## Parameters

    - `p`: The name of the parameter.
    - `type`: The type of the parameter, which can be one of the following atoms:
      - `:tdouble`
      - `:tfloat`
      - `:tint`
      - `:matrex`
      - `:float`
      - `:int`
      - `:double`
    - Anything that is not one of these atoms will return `nil`. This is purposely done to let functions being
    treated separately.

  ## Returns
    - A string representing the OpenCL parameter declaration, or `nil` if the type is not recognized.
  """
  def gen_para(p, :tdouble) do
    "double *#{p}"
  end

  def gen_para(p, :tfloat) do
    "float *#{p}"
  end

  def gen_para(p, :tint) do
    "int *#{p}"
  end

  def gen_para(p, :matrex) do
    "float *#{p}"
  end

  def gen_para(p, :float) do
    "float #{p}"
  end

  def gen_para(p, :int) do
    "int #{p}"
  end

  def gen_para(p, :double) do
    "double #{p}"
  end

  def gen_para(_p, {_ret, _type}) do
    nil
  end

  @doc """
  Generates the OpenCL kernel declaration string.
  ## Parameters

    - `name`: The name of the kernel.
    - `para`: A string representing the parameters of the kernel.
    - `body`: A string representing the body of the kernel.

  ## Returns
    - A string representing the complete OpenCL kernel declaration.
  """
  def gen_kernel_jit(name, para, body) do
    "__kernel void #{name}(#{para})\n{\n#{body}\n}"
  end

  @doc """
  Generates the OpenCL device function declaration string.

  ## Parameters

    - `name`: The name of the function.
    - `para`: A string representing the parameters of the function.
    - `body`: A string representing the body of the function.
    - `type`: The return type of the function as a string.

    ## Returns
    - A string representing the complete OpenCL device function declaration.
  """
  def gen_function_jit(name, para, body, type) do
    # OpenCL doesn't need a special qualifier for device functions
    "#{type} #{name}(#{para})\n{\n#{body}\n}"
  end

  ########################## ADDING RETURN statement to the ast WHEN FUNCTION RETURNS AN EXPRESSION

  @doc """
  Adds a return statement to the given body of code if the function returns an expression.

  ## Parameters

    - `body`: The body of code, which can be a single expression or a block of expressions.

  ## Returns
    - The modified body of code with a return statement added if necessary.
  """
  def add_return(body) do
    case body do
      {:__block__, pos, code} ->
        {:__block__, pos, check_return(code)}

      {:do, {:__block__, pos, code}} ->
        {:do, {:__block__, pos, check_return(code)}}

      {:do, exp} ->
        case exp do
          {:return, _, _} ->
            {:do, exp}

          _ ->
            if is_exp?(exp) do
              {:do, {:return, [], [exp]}}
            else
              {:do, exp}
            end
        end

      {_, _, _} ->
        if is_exp?(body) do
          {:return, [], [body]}
        else
          body
        end
    end

    # end
  end

  defp check_return([com]) do
    case com do
      {:return, _, _} ->
        [com]

      {:if, info, [exp, [do: block]]} ->
        {:if, info, [exp, [do: check_return(block)]]}

      {:if, info, [exp, [do: block, else: belse]]} ->
        {:if, info, [exp, [do: check_return(block), else: check_return(belse)]]}

      _ ->
        if is_exp?(com) do
          [{:return, [], [com]}]
        else
          [com]
        end

        # h -> raise "unknown #{inspect h}"
    end
  end

  defp check_return([h | t]) do
    [h | check_return(t)]
  end

  defp is_exp?(exp) do
    case exp do
      {{:., _info, [Access, :get]}, _, [_arg1, _arg2]} -> true
      {{:., _, [{_struct, _, nil}, _field]}, _, []} -> true
      {{:., _, [{:__aliases__, _, [_struct]}, _field]}, _, []} -> true
      {op, _info, _args} when op in [:+, :-, :/, :*] -> true
      {op, _info, [_arg1, _arg2]} when op in [:<=, :<, :>, :>=, :!=, :==] -> true
      {:!, _info, [_arg]} -> true
      {op, _inf, _args} when op in [:&&, :||] -> true
      {var, _info, nil} when is_atom(var) -> true
      {_fun, _, args} when is_list(args) -> true
      # {_fun, _, _noargs} ->
      float when is_float(float) -> true
      int when is_integer(int) -> true
      string when is_binary(string) -> true
      _ -> false
    end
  end

  @doc """
  Generates OpenCL code from the given body, types, parameter variables, module and function substitutions (used when replacing high-order function names, e.g., anonymous functions).
  """
  def gen_ocl_jit(body, types, param_vars, module, subs) do
    # IO.puts "##########################gen cuda"
    # IO.inspect types
    #  IO.puts "############end gen cuda"
    # raise "hell"
    # IO.puts "gen_ocl"
    # IO.inspect param_vars
    pid = spawn_link(fn -> types_server(param_vars, types, module, subs) end)
    Process.register(pid, :types_server)
    code = gen_body(body)
    send(pid, {:kill})
    Process.unregister(:types_server)
    code
  end

  # Generates the body of OpenCL code from the given AST body.
  defp gen_body(body) do
    case body do
      {:__block__, _, _code} ->
        gen_block(body)

      {:do, {:__block__, pos, code}} ->
        gen_block({:__block__, pos, code})

      {:do, exp} ->
        gen_command(exp)

      {_, _, _} ->
        gen_command(body)
    end
  end

  # Generates a block of OpenCL code from the given AST block.
  defp gen_block({:__block__, _, code}) do
    code
    |> Enum.map(&gen_command/1)
    |> Enum.join("\n")
  end

  # Generates for loop OpenCL code based on the provided AST header.
  defp gen_header_for(header) do
    case header do
      {:in, _, [{var, _, nil}, {:range, _, [n]}]} ->
        "for( int #{var} = 0; #{var}<#{gen_exp(n)}; #{var}++)"

      {:in, _, [{var, _, nil}, {:range, _, [argr1, argr2]}]} ->
        "for( int #{var} = #{gen_exp(argr1)}; #{var}<#{gen_exp(argr2)}; #{var}++)"

      {:in, _, [{var, _, nil}, {:range, _, [argr1, argr2, step]}]} ->
        "for( int #{var} = #{gen_exp(argr1)}; #{var}<#{gen_exp(argr2)}; #{var}+=#{gen_exp(step)})"
    end
  end

  # Tries to retrieve the actual name of a function from the types server.
  defp check_fun(fun) do
    send(:types_server, {:check_fun, fun, self()})

    receive do
      {:fun_info, nn} -> nn
      h -> raise "Unknown message from type server #{inspect(h)}"
    end
  end

  # Generates OpenCL code for a given AST node command.
  defp gen_command(code) do
    case code do
      {:for, _, [param, [body]]} ->
        header = gen_header_for(param)
        body = gen_body(body)
        header <> "{\n" <> body <> "\n}\n"

      {:=, _, [arg, exp]} ->
        a = gen_exp(arg)
        e = gen_exp(exp)

        case arg do
          # Accessing array index
          {{:., _, [Access, :get]}, _, [_, _]} ->
            "\t#{a} = #{e}\;"

          _ ->
            send(:types_server, {:check_var, a, self()})

            receive do
              {:is_typed} ->
                "\t#{a} = #{e}\;"

              {:type, type} ->
                "\t#{type} #{a} = #{e}\;"

              {:alredy_declared} ->
                "\t#{a} = #{e}\;"
            end
        end

      {:if, _, if_com} ->
        genIf(if_com)

      {:do_while, _, [[doblock]]} ->
        "do{\n" <> gen_body(doblock)

      {:do_while_test, _, [exp]} ->
        "\nwhile(" <> gen_exp(exp) <> ");"

      {:while, _, [bexp, [body]]} ->
        "while(" <> gen_exp(bexp) <> "){\n" <> gen_body(body) <> "\n}"

      # CRIAÇÃO DE NOVOS VETORES
      {{:., _, [Access, :get]}, _, [arg1, arg2]} ->
        name = gen_exp(arg1)
        index = gen_exp(arg2)
        "float #{name}[#{index}];"

      # Work-group shared memory declaration
      {:__shared__, _, [{{:., _, [Access, :get]}, _, [arg1, arg2]}]} ->
        name = gen_exp(arg1)
        index = gen_exp(arg2)
        send(:types_server, {:check_var, name, self()})

        atype =
          receive do
            {:type, type} ->
              case type do
                :tint -> :int
                :tfloat -> :float
                :tdouble -> :double
                u -> raise "Type #{u} given to array #{name}"
              end

            _ ->
              raise "Var #{name} already declared."
          end

        "__local #{atype} #{name}[#{index}];"

      {:__syncthreads, _, _} ->
        # OpenCL equivalent of __syncthreads() in CUDA
        "barrier(CLK_LOCAL_MEM_FENCE);"

      {:var, _, [{var, _, [{:=, _, [{type, _, nil}, exp]}]}]} ->
        # IO.puts "aqui"
        gexp = gen_exp(exp)
        "#{to_string(type)} #{to_string(var)} = #{gexp};"

      {:var, _, [{var, _, [{:=, _, [type, exp]}]}]} ->
        gexp = gen_exp(exp)
        "#{to_string(type)} #{to_string(var)} = #{gexp};"

      {:var, _, [{var, _, [{type, _, _}]}]} ->
        "#{to_string(type)} #{to_string(var)};"

      {:var, _, [{var, _, [type]}]} ->
        "#{to_string(type)} #{to_string(var)};"

      {:type, _, [{_, _, [{_, _, _}]}]} ->
        ""

      {:type, _, [{_, _, _}]} ->
        ""

      {:return, _, [arg]} ->
        "return (#{gen_exp(arg)});"

      {fun, _, args} when is_list(args) ->
        # module = get_module_name()
        nargs =
          args
          |> Enum.map(&gen_exp/1)
          |> Enum.join(", ")

        nfun = check_fun(fun)

        if nfun == nil do
          "#{fun}(#{nargs});"
        else
          "#{nfun}(#{nargs});"
        end

      {str, _, _} ->
        "#{to_string(str)};"

      number when is_integer(number) or is_float(number) ->
        to_string(number)
        # string when is_string(string)) -> string #to_string(number)
    end
  end

  # Gera uma expressão em C a partir de uma expressão PolyHok.
  defp gen_exp(exp) do
    case exp do
      # Acesso a um índice de um array
      {{:., _, [Access, :get]}, _, [arg1, arg2]} ->
        name = gen_exp(arg1)
        index = gen_exp(arg2)
        "#{name}[#{index}]"

      # Accessing special GPU indexing structures (like threadIdx.x, blockIdx.y, etc.)
      {{:., _, [{struct, _, _}, field]}, _, []}
      when struct in [:threadIdx, :blockIdx, :blockDim, :gridDim] ->
        output_function =
          case struct do
            :threadIdx -> "get_local_id"
            :blockIdx -> "get_group_id"
            :blockDim -> "get_local_size"
            :gridDim -> "get_num_groups"
          end

        output_dim_arg =
          case field do
            :x -> "0"
            :y -> "1"
            :z -> "2"
            _ -> raise "Unknown field #{field} in special struct #{struct}"
          end

        "#{output_function}(#{output_dim_arg})"

      # Acesso a um campo de uma estrutura normal
      # Deixei um IO.puts para debug caso algum comportamento estranho aconteça e precisemos investigar
      {{:., _, [{struct, _, _}, field]}, _, []} ->
        IO.puts("[BACKEND] Acessing #{struct} with field #{field}")
        "#{to_string(struct)}.#{to_string(field)}"

      # Acesso a um campo de uma estrutura com alias (não sei exatamente por que essa cláusula é necessária
      # por isso deixei um IO.puts para debug)
      {{:., _, [{:__aliases__, _, [struct]}, field]}, _, []} ->
        IO.puts("[BACKEND] Acessing #{struct} with alias and field #{field}")
        "#{to_string(struct)}.#{to_string(field)}"

      # Square root of float (in OpenCL we don't need special function names for different types)
      # I left this here for old cold compatibility, because otherwise it would try to call sqrtf, and this
      # doesn't exist in OpenCL
      {:sqrtf, _, [arg]} ->
        "sqrt(#{gen_exp(arg)})"

      {op, _, args} when op in [:+, :-, :/, :*, :<=, :<, :>, :>=, :&&, :||, :!, :!=, :==] ->
        case args do
          [a1] ->
            "(#{to_string(op)} #{gen_exp(a1)})"

          [a1, a2] ->
            "(#{gen_exp(a1)} #{to_string(op)} #{gen_exp(a2)})"
        end

      {var, _, nil} when is_atom(var) ->
        to_string(var)

      {fun, _, args} ->
        nargs =
          args
          |> Enum.map(&gen_exp/1)
          |> Enum.join(", ")

        nfun = check_fun(fun)

        if nfun == nil do
          "#{fun}(#{nargs})"
        else
          "#{nfun}(#{nargs})"
        end

      number when is_integer(number) or is_float(number) ->
        to_string(number)

      string when is_binary(string) ->
        "\"#{string}\""
    end
  end

  defp genIf([bexp, [do: then]]) do
    gen_then([bexp, [do: then]])
  end

  defp genIf([bexp, [do: thenbranch, else: elsebranch]]) do
    gen_then([bexp, [do: thenbranch]]) <>
      "else{\n" <>
      gen_body(elsebranch) <>
      "\n}\n"
  end

  defp gen_then([bexp, [do: then]]) do
    "if(#{gen_exp(bexp)})\n" <>
      "{\n" <>
      gen_body(then) <>
      "\n}\n"
  end

  # Retrieves the module name from the types server.
  def get_module_name() do
    send(:types_server, {:module, self()})

    receive do
      {:module, name} -> name
      _ -> raise "Unknown message from types server."
    end
  end

  @doc """
  Types server process that manages module name, variable types, function types, and substitutions.
  """
  def types_server(used, types, module, subs) do
    receive do
      {:module, pid} ->
        send(pid, {:module, module})
        types_server(used, types, module, subs)

      {:check_var, var, pid} ->
        if !Enum.member?(used, var) do
          type = Map.get(types, String.to_atom(var))

          if(type == nil) do
            # IO.inspect var
            # IO.inspect types
            raise "Could not find type for variable #{var}. Please declare it using \"var #{var} type\""
          end

          send(pid, {:type, type})
          types_server([var | used], types, module, subs)
        else
          send(pid, {:alredy_declared})
          types_server(used, types, module, subs)
        end

      {:check_return, pid} ->
        send(pid, Map.get(types, :return))
        types_server(used, types, module, subs)

      {:check_fun, name, pid} ->
        send(pid, {:fun_info, Map.get(subs, name)})
        types_server(used, types, module, subs)

      {:kill} ->
        :ok
    end
  end
end
